# 6502/6510 CPU Reference

## Overview

The 6510 CPU (6502 variant) in the C64 has a built-in I/O port at $0000-$0001 for memory banking. Otherwise identical to standard 6502.

**Architecture:**
- 8-bit accumulator (A)
- Two 8-bit index registers (X, Y)
- 8-bit stack pointer (S)
- 16-bit program counter (PC)
- 8-bit status register (P)
- 256-byte stack ($0100-$01FF)
- Little-endian byte order

**Clock speed:**
- NTSC: ~1.023 MHz
- PAL: ~0.985 MHz

## Registers

### Accumulator (A)
Primary data register for arithmetic/logic operations.

### Index Registers (X, Y)
Used for indexed addressing modes, loop counters, temporary storage.

### Stack Pointer (S)
Points to next free stack location ($0100-$01FF). Grows downward from $01FF.

### Program Counter (PC)
16-bit address of next instruction to execute.

### Status Register (P)

| Bit | Flag | Name | Function |
|-----|------|------|----------|
| 7 | N | Negative | Set if bit 7 of result is 1 |
| 6 | V | Overflow | Set on signed arithmetic overflow |
| 5 | - | Unused | Always 1 |
| 4 | B | Break | Set by BRK instruction |
| 3 | D | Decimal | BCD mode (not used on C64) |
| 2 | I | Interrupt | IRQ disable (1=disabled) |
| 1 | Z | Zero | Set if result is zero |
| 0 | C | Carry | Set on carry/borrow |

## Addressing Modes

### Implied
Instruction operates on register or has no operand.
```
INX         ; Increment X
RTS         ; Return from subroutine
```

### Accumulator
Operation on accumulator.
```
ASL A       ; Arithmetic shift left A
```

### Immediate (#)
Operand is constant value.
```
LDA #$42    ; Load A with literal $42
```

### Zero Page ($nn)
8-bit address in zero page ($0000-$00FF). Faster than absolute.
```
LDA $FB     ; Load A from $00FB
STA $FC     ; Store A to $00FC
```

### Zero Page,X ($nn,X)
Zero page address + X register.
```
LDA $80,X   ; Load from $0080 + X
```

### Zero Page,Y ($nn,Y)
Zero page address + Y register (LDX/STX only).
```
LDX $80,Y   ; Load X from $0080 + Y
```

### Absolute ($nnnn)
16-bit address.
```
LDA $C000   ; Load from $C000
JMP $FFD2   ; Jump to $FFD2
```

### Absolute,X ($nnnn,X)
16-bit address + X register.
```
LDA $C000,X ; Load from $C000 + X
```

### Absolute,Y ($nnnn,Y)
16-bit address + Y register.
```
LDA $C000,Y ; Load from $C000 + Y
```

### Indirect (($nnnn))
Jump to address stored at given address (JMP only).
```
JMP ($FFFE) ; Jump to address at $FFFE/$FFFF
```

### Indexed Indirect (($nn,X))
Zero page address + X, then read address from result.
```
LDA ($80,X) ; X=2: read addr from $82/$83, load from that addr
```

### Indirect Indexed (($nn),Y)
Read address from zero page, then add Y.
```
LDA ($FB),Y ; Read addr from $FB/$FC, add Y, load from result
```

### Relative (branch)
8-bit signed offset (-128 to +127) for branch instructions.
```
BEQ LABEL   ; Branch if zero flag set
```

## Instruction Set

### Load/Store

| Mnemonic | Description | Flags | Cycles |
|----------|-------------|-------|--------|
| LDA | Load accumulator | N Z | 2-5 |
| LDX | Load X register | N Z | 2-4 |
| LDY | Load Y register | N Z | 2-4 |
| STA | Store accumulator | - | 3-5 |
| STX | Store X register | - | 3-4 |
| STY | Store Y register | - | 3-4 |

### Transfer

| Mnemonic | Description | Flags | Cycles |
|----------|-------------|-------|--------|
| TAX | Transfer A to X | N Z | 2 |
| TAY | Transfer A to Y | N Z | 2 |
| TXA | Transfer X to A | N Z | 2 |
| TYA | Transfer Y to A | N Z | 2 |
| TSX | Transfer SP to X | N Z | 2 |
| TXS | Transfer X to SP | - | 2 |

### Stack

| Mnemonic | Description | Flags | Cycles |
|----------|-------------|-------|--------|
| PHA | Push A to stack | - | 3 |
| PHP | Push status to stack | - | 3 |
| PLA | Pull A from stack | N Z | 4 |
| PLP | Pull status from stack | All | 4 |

### Arithmetic

| Mnemonic | Description | Flags | Cycles |
|----------|-------------|-------|--------|
| ADC | Add with carry | N V Z C | 2-5 |
| SBC | Subtract with carry | N V Z C | 2-5 |
| INC | Increment memory | N Z | 5-6 |
| INX | Increment X | N Z | 2 |
| INY | Increment Y | N Z | 2 |
| DEC | Decrement memory | N Z | 5-6 |
| DEX | Decrement X | N Z | 2 |
| DEY | Decrement Y | N Z | 2 |

### Logical

| Mnemonic | Description | Flags | Cycles |
|----------|-------------|-------|--------|
| AND | Logical AND | N Z | 2-5 |
| ORA | Logical OR | N Z | 2-5 |
| EOR | Exclusive OR | N Z | 2-5 |
| BIT | Bit test | N V Z | 3-4 |

### Shift/Rotate

| Mnemonic | Description | Flags | Cycles |
|----------|-------------|-------|--------|
| ASL | Arithmetic shift left | N Z C | 2-6 |
| LSR | Logical shift right | N Z C | 2-6 |
| ROL | Rotate left | N Z C | 2-6 |
| ROR | Rotate right | N Z C | 2-6 |

### Branch (Relative)

| Mnemonic | Description | Condition | Cycles |
|----------|-------------|-----------|--------|
| BCC | Branch if carry clear | C=0 | 2-4 |
| BCS | Branch if carry set | C=1 | 2-4 |
| BEQ | Branch if equal (zero) | Z=1 | 2-4 |
| BNE | Branch not equal | Z=0 | 2-4 |
| BMI | Branch if minus | N=1 | 2-4 |
| BPL | Branch if plus | N=0 | 2-4 |
| BVC | Branch if overflow clear | V=0 | 2-4 |
| BVS | Branch if overflow set | V=1 | 2-4 |

### Jump/Subroutine

| Mnemonic | Description | Flags | Cycles |
|----------|-------------|-------|--------|
| JMP | Jump to address | - | 3-5 |
| JSR | Jump to subroutine | - | 6 |
| RTS | Return from subroutine | - | 6 |
| RTI | Return from interrupt | All | 6 |
| BRK | Software interrupt | B I | 7 |

### Compare

| Mnemonic | Description | Flags | Cycles |
|----------|-------------|-------|--------|
| CMP | Compare with A | N Z C | 2-5 |
| CPX | Compare with X | N Z C | 2-4 |
| CPY | Compare with Y | N Z C | 2-4 |

### Status Flags

| Mnemonic | Description | Flags | Cycles |
|----------|-------------|-------|--------|
| CLC | Clear carry | C=0 | 2 |
| CLD | Clear decimal | D=0 | 2 |
| CLI | Clear interrupt | I=0 | 2 |
| CLV | Clear overflow | V=0 | 2 |
| SEC | Set carry | C=1 | 2 |
| SED | Set decimal | D=1 | 2 |
| SEI | Set interrupt | I=1 | 2 |

### System

| Mnemonic | Description | Flags | Cycles |
|----------|-------------|-------|--------|
| NOP | No operation | - | 2 |

## Common Code Patterns

### Copy Byte
```assembly
LDA SOURCE
STA DEST
```

### Copy Word (16-bit)
```assembly
LDA SOURCE
STA DEST
LDA SOURCE+1
STA DEST+1
```

### Clear Memory
```assembly
LDA #$00
LDX #$00
LOOP:
STA $C000,X
INX
BNE LOOP
```

### 16-bit Addition
```assembly
CLC
LDA NUM1_LO
ADC NUM2_LO
STA RESULT_LO
LDA NUM1_HI
ADC NUM2_HI
STA RESULT_HI
```

### Loop Counter
```assembly
LDX #$0A       ; 10 iterations
LOOP:
; ... code ...
DEX
BNE LOOP
```

### Conditional Branch
```assembly
LDA VALUE
CMP #$42
BEQ EQUAL      ; Branch if A = $42
BNE NOTEQUAL   ; Branch if A ≠ $42
```

### Multiply by 2 (Shift Left)
```assembly
LDA VALUE
ASL A          ; A = A * 2
```

### Divide by 2 (Shift Right)
```assembly
LDA VALUE
LSR A          ; A = A / 2
```

### Test Bit
```assembly
LDA VALUE
AND #$80       ; Test bit 7
BEQ BIT_CLEAR
BNE BIT_SET
```

### Set Bit
```assembly
LDA VALUE
ORA #$80       ; Set bit 7
STA VALUE
```

### Clear Bit
```assembly
LDA VALUE
AND #$7F       ; Clear bit 7 (all except bit 7)
STA VALUE
```

### Toggle Bit
```assembly
LDA VALUE
EOR #$80       ; Toggle bit 7
STA VALUE
```

### Wait Loop
```assembly
LDX #$00
OUTER:
LDY #$00
INNER:
DEY
BNE INNER
DEX
BNE OUTER
```

### Table Lookup
```assembly
LDX INDEX
LDA TABLE,X
STA RESULT

TABLE:
.BYTE $01,$02,$03,$04
```

### Indirect Jump Table
```assembly
LDX FUNC_NUM
LDA JUMPTBL,X
STA $FB
LDA JUMPTBL+1,X
STA $FC
JMP ($FB)

JUMPTBL:
.WORD FUNC0, FUNC1, FUNC2
```

## Stack Operations

Stack at $0100-$01FF, grows downward.

### Push/Pull
```assembly
LDA #$42
PHA            ; Push A ($01FF, SP=$FE)
; ...
PLA            ; Pull A (SP=$FF)
```

### Preserve Registers
```assembly
SUBR:
PHA            ; Save A
TXA
PHA            ; Save X
TYA
PHA            ; Save Y
; ... code ...
PLA            ; Restore Y
TAY
PLA            ; Restore X
TAX
PLA            ; Restore A
RTS
```

### Stack Pointer Manipulation
```assembly
TSX            ; X = SP
DEX
DEX            ; Adjust
TXS            ; SP = X
```

## Subroutines

### Call/Return
```assembly
JSR SUBR       ; Call subroutine
; ... continues here after RTS

SUBR:
; ... code ...
RTS            ; Return
```

### Passing Parameters (Zero Page)
```assembly
LDA #$10
STA $FB        ; Parameter 1
LDA #$20
STA $FC        ; Parameter 2
JSR SUBR

SUBR:
LDA $FB
CLC
ADC $FC
STA $FD        ; Result
RTS
```

### Passing Parameters (Stack)
```assembly
LDA #$20       ; Second param
PHA
LDA #$10       ; First param
PHA
JSR SUBR

SUBR:
PLA            ; Get first param
STA $FB
PLA            ; Get second param
STA $FC
; ... use $FB/$FC ...
RTS
```

## Interrupts

### IRQ Handler
```assembly
IRQ_HANDLER:
PHA            ; Save A
TXA
PHA            ; Save X
TYA
PHA            ; Save Y
; ... custom IRQ code ...
PLA
TAY            ; Restore Y
PLA
TAX            ; Restore X
PLA            ; Restore A
RTI            ; Return from interrupt
```

### Installing IRQ
```assembly
SEI            ; Disable interrupts
LDA #<IRQ_HANDLER
STA $0314      ; IRQ vector low
LDA #>IRQ_HANDLER
STA $0315      ; IRQ vector high
CLI            ; Enable interrupts
```

### NMI Handler
Similar to IRQ but uses vector at $FFFA/$FFFB (or $0318/$0319 in RAM).

## 6510 Processor Port ($0000/$0001)

Unique to 6510 (not in standard 6502).

### $0000 - Data Direction
- 0 = input
- 1 = output

### $0001 - I/O Port
Controls memory banking and cassette.

| Bit | Function |
|-----|----------|
| 0 | LORAM (0=RAM at $A000, 1=BASIC ROM) |
| 1 | HIRAM (0=RAM at $E000, 1=KERNAL ROM) |
| 2 | CHAREN (0=Char ROM at $D000, 1=I/O) |
| 3 | Cassette data output |
| 4 | Cassette switch sense |
| 5 | Cassette motor control |

**Common values:**
- $37 (55): Default (all ROM/I/O visible)
- $34 (52): Character ROM readable
- $33 (51): I/O visible, BASIC/KERNAL as RAM
- $30 (48): All RAM mode

## Cycle Timing

### Base Cycles by Addressing Mode

| Mode | Read | Write | RMW |
|------|------|-------|-----|
| Implied/Accumulator | 2 | - | 2 |
| Immediate | 2 | - | - |
| Zero Page | 3 | 3 | 5 |
| Zero Page,X/Y | 4 | 4 | 6 |
| Absolute | 4 | 4 | 6 |
| Absolute,X/Y | 4-5* | 5 | 7 |
| (Indirect,X) | 6 | 6 | 8 |
| (Indirect),Y | 5-6* | 6 | 8 |

*Add 1 cycle if page boundary crossed.

### Special Instructions

| Instruction | Cycles |
|-------------|--------|
| BRK | 7 |
| JSR | 6 |
| RTS | 6 |
| RTI | 6 |
| JMP abs | 3 |
| JMP (ind) | 5 |
| PHA/PHP | 3 |
| PLA/PLP | 4 |
| Branch not taken | 2 |
| Branch taken, same page | 3 |
| Branch taken, different page | 4 |

## Page Boundary Crossing

Some indexed instructions take +1 cycle when crossing page boundary:
- LDA/LDX/LDY/EOR/AND/ORA/ADC/SBC/CMP with ,X or ,Y
- Absolute,X/Y and (Indirect),Y modes

**Example:**
```assembly
LDA $C0FF,X    ; X=$01: crosses page ($C0FF→$C100), +1 cycle
LDA $C000,X    ; X=$FF: crosses page ($C000→$C0FF), +1 cycle
```

## Undocumented Opcodes

The 6502 has undocumented opcodes. **Avoid using them** - behavior varies by chip revision and may cause instability.

## Assembler Syntax

### Typical Syntax
```assembly
LABEL:  LDA #$42    ; Comment
        STA $FB
        RTS
```

### Directives (assembler-dependent)
```assembly
* = $C000          ; Origin
.BYTE $01,$02      ; Byte data
.WORD $C000        ; Word data (little-endian)
.TEXT "HELLO"      ; String data
```

## Practical Examples

### BASIC ML Wrapper
```assembly
* = $C000
        LDA #$05       ; White
        STA $D021      ; Background
        LDA #$00       ; Black
        STA $D020      ; Border
        RTS
```

BASIC loader:
```basic
10 FOR I=0 TO 8
20   READ B: POKE 49152+I,B
30 NEXT
40 SYS 49152
50 DATA 169,5,141,33,208,169,0,141,32,208,96
```

### Print String via KERNAL
```assembly
* = $C000
        LDX #$00
LOOP:   LDA TEXT,X
        BEQ DONE
        JSR $FFD2      ; CHROUT
        INX
        BNE LOOP
DONE:   RTS

TEXT:   .TEXT "HELLO WORLD"
        .BYTE $00
```

### Sprite Movement
```assembly
* = $C000
        LDA XPOS
        CLC
        ADC #$01       ; Move right
        STA XPOS
        STA $D000      ; Sprite 0 X
        CMP #$FF
        BNE DONE
        ; Handle X > 255
        LDA $D010
        ORA #$01
        STA $D010
DONE:   RTS

XPOS:   .BYTE $00
```

### Fast Clear Screen
```assembly
* = $C000
        LDA #$20       ; Space
        LDX #$00
LOOP1:  STA $0400,X
        STA $0500,X
        STA $0600,X
        STA $06E8,X
        INX
        BNE LOOP1
        RTS
```

### Raster Sync
```assembly
WAIT:   LDA $D012      ; Current raster
        CMP #$80       ; Wait for line 128
        BNE WAIT
        RTS
```

## Debugging

### Breakpoint (BRK)
```assembly
BRK                ; Software interrupt
```

Execution stops, jumps to BRK vector ($0316/$0317).

### Monitor Commands (depends on monitor)
```
M C000 C0FF        ; Memory dump
D C000             ; Disassemble
G C000             ; Go (execute)
X                  ; Show registers
```

## Optimization Tips

1. **Use zero page** - faster than absolute addressing
2. **Avoid page boundary crossings** - check indexed accesses
3. **Unroll loops** - trade size for speed
4. **Use Y for tables** - often more efficient
5. **Branch prediction** - organize code for common path
6. **Minimize memory access** - keep values in registers

## Quick Reference

**Registers:** A, X, Y, SP, PC, P  
**Stack:** $0100-$01FF (grows down)  
**Flags:** N V - B D I Z C  
**Addressing:** 13 modes  
**Instructions:** 56 official opcodes  
**Speed:** ~1 MHz (~1 million cycles/sec)

---